{"noir_version":"1.0.0-beta.12+9a5b3695b42e391fa27c48e87b9bbb07523d664d","hash":"16862304230447105664","abi":{"parameters":[{"name":"user_lat","type":{"kind":"integer","sign":"signed","width":64},"visibility":"private"},{"name":"user_lon","type":{"kind":"integer","sign":"signed","width":64},"visibility":"private"},{"name":"target_lat","type":{"kind":"integer","sign":"signed","width":64},"visibility":"public"},{"name":"target_lon","type":{"kind":"integer","sign":"signed","width":64},"visibility":"public"},{"name":"radius_meters","type":{"kind":"integer","sign":"signed","width":64},"visibility":"public"}],"return_type":null,"error_types":{"2373659303924614330":{"error_kind":"string","string":"User is outside the specified radius"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"4696375007458979588":{"error_kind":"string","string":"bad user_lon"},"4742109169293497338":{"error_kind":"string","string":"bad target_lat"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8002249748234416266":{"error_kind":"string","string":"bad user_lat"},"12604764607938998964":{"error_kind":"string","string":"bad radius"},"13237450239867164652":{"error_kind":"string","string":"bad target_lon"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"pZjNThtLEIXfxWsvpqv/qngVhJABJ7JkGeTgSFeId79dXeeYZBEJjTf+DiH1GTzucR0+Ni/7p8vPx8Ppx+uvzd39x+bpfDgeDz8fj6/Pu/fD62n868dm8QeTzV3abiwHSqAGWqAHNGATaVnABAqYwQJWsIEdVBC+BF+CL8GX4EvwJfgSfAm+BF+CT+AT+AQ+gU/gE/gEPoFP4BP4MnwZvgxfhi/Dl+HL8GX4MnwZvgJfga/AV+Ar8BX4CnwFvgJfga/CV+Gr8FX4KnwVvgpfha/CV+Fr8DX4GnwNvgZfg6/B1+Br8DX4Onwdvg5fHz5xFrCCwyefn9sN37OP7+f93t+yf7yJx1v7bXfen943d6fL8bjd/N4dL/M//XrbnSbfd+fx3WW72Z9eBofwx+G49/S5/Zpe/j2qljBskq/jIt+d76VjvuuyYr4In7+Ucp2v3/75y/X5S7M181/Pv27eDPP1j9fv+/NVGufLjc+/ar52zrdlzevfFr7+Lafbnn/VfGuZ87rm928mfP+mftPzr5vvhb9/b23NfLvOW77t+VfNa+b50Spr5nvhvNUV85bkev+yVfPX+19eNV8r57usmufvb7pmfmwo/AVG1FUG+TKI3vozrDRcX8axOpVVBlMaxjazxpA6b2VjffrntRBb82H6ML7aPR/Of++oYxkYd482H/t81Plo89F3RkcKSGAsFMUXo0ANtEAPaMAmfFN0DMt4iX1PdAzL+NzxLdFRAy3QAxqwCd8PHcMyXiTfDh05UAI10AI9oIFhGZfHt0LHsIxX0XdCRw6UQA20QA9owJetcQXnMuhMoIAZLGAFG+jL27hCcxl0um/cPuYy6EyggBksYAUb6D6/gApacC6DzgQKmMECum9cG18GJ903rk5X0IK6gAkUMIMFdN+4StrADipoQVvABArovo6e1FGUFE1JUZUUXUlRlpRtSVmXlH1JWZiUjUlZmZSdSVmalK1JWZuUvUlZnJTNSVmdlN1JWZ6U7UlZn5T9SVmglA3KWKGMHcpYoowtylijjD3KWKSMTcpYpYxdylimjG3KWKeMfcpYqIyNylipjJ3KWKqMrcpYq4y9ylisjM3KUK1kQbeK0BmUwRD8SEVIDMKQGQqDm9myhDVL2LOERUvYtIRVS9i1hGVL2LaEdUvYt4SFS9i4hJVL2LmEpUvYuuRauxJ7V2LxujavGTqDMhiCH7gIiUEYMkNhcLPfmf3YRegMymAIfvQiJAZhyAyFgWaj2Wg2mg1mWRaGxCAMmaEwuHl+ODSGzqAMhuBnMEJiEIbMUBhoTjQnmhPNiWah2c+gzI8nYcgMhaEyNIbOoAyG4GcwAs2Z5kxzpjnTnGn2M+jFTPwMRjAEP4MREoMwZIbCUBkaA82F5kJzpbnSXGmuNFeaK82V5kpzpbnS3GhuNM8z2D1khsJQGRpDZ1AGQ5hncIbEQHOnudPcae40zzOoHpTBEOYZnCExCENmKAyVoTHQrDQrzUaz0exncO6Mv3fnw+7puPftzPe3y+mZy9r48v2/N36Hf3J8O78+718u570vdl9/dxw/4P0otmoPscbdj5vMdtw7Hj59Ffwf","file_map":{"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\n/// Asserts the validity of the provided proof and public inputs against the provided verification key and hash.\n///\n/// The ACVM cannot determine whether the provided proof is valid during execution as this requires knowledge of\n/// the backend against which the program is being proven. However if an invalid proof if submitted, the program may\n/// fail to prove or the backend may generate a proof which will subsequently fail to verify.\n///\n/// # Important Note\n///\n/// If you are not developing your own backend such as [Barretenberg](https://github.com/AztecProtocol/barretenberg)\n/// you probably shouldn't need to interact with this function directly. It's easier and safer to use a verification\n/// library which is published by the developers of the backend which will document or enforce any safety requirements.\n///\n/// If you use this directly, you're liable to introduce underconstrainedness bugs and *your circuit will be insecure*.\n///\n/// # Arguments\n/// - verification_key: The verification key of the circuit to be verified.\n/// - proof: The proof to be verified.\n/// - public_inputs: The public inputs associated with `proof`\n/// - key_hash: The hash of `verification_key` of the form expected by the backend.\n/// - proof_type: An identifier for the proving scheme used to generate the proof to be verified. This allows\n///               for a single backend to support verifying multiple proving schemes.\n///\n/// # Constraining `key_hash`\n///\n/// The Noir compiler does not by itself constrain that `key_hash` is a valid hash of `verification_key`.\n/// This is because different backends may differ in how they hash their verification keys.\n/// It is then the responsibility of either the noir developer (by explicitly hashing the verification key\n/// in the correct manner) or by the proving system itself internally asserting the correctness of `key_hash`.\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n","path":"std/lib.nr"},"50":{"source":"// main function now takes the target coordinates and radius as inputs.\n// In a real ZKP context:\n// - user_lat, user_lon would be PRIVATE inputs.\n// - target_lat, target_lon, radius_meters would be PUBLIC inputs.\nfn main(\n    user_lat: i64,\n    user_lon: i64,\n    target_lat: pub i64,\n    target_lon: pub i64,\n    radius_meters: pub i64,\n) {\n    // Input bounds (micro-degrees for lat/lon; meters for radius)\n    assert(user_lat >= -90_000_000 & user_lat <= 90_000_000, \"bad user_lat\");\n    assert(user_lon >= -180_000_000 & user_lon <= 180_000_000, \"bad user_lon\");\n    assert(target_lat >= -90_000_000 & target_lat <= 90_000_000, \"bad target_lat\");\n    assert(target_lon >= -180_000_000 & target_lon <= 180_000_000, \"bad target_lon\");\n    assert(radius_meters > 0 & radius_meters <= 100_000, \"bad radius\");\n\n    let delta_lat = user_lat - target_lat;\n    let delta_lon = user_lon - target_lon;\n\n    let dy = (delta_lat * 11132) / 100000;\n    let dx = (delta_lon * 11132) / 100000;\n\n    let square_distance = dx * dx + dy * dy;\n    let radius_squared = radius_meters * radius_meters;\n\n    assert(square_distance < radius_squared, \"User is outside the specified radius\");\n    println(\"Proof successful: User is within the specified radius.\");\n}\n\n// The sqrt_approx function is no longer needed!\n\n// --- TESTS ---\n\n#[test]\nfn test_eiffel_tower_success() {\n    // Public Inputs: Prove you are within 50m of the Eiffel Tower\n    let eiffel_tower_lat: i64 = 48_858_370; // 48.858370\n    let eiffel_tower_lon: i64 = 2_294_481; // 2.294481\n    let radius: i64 = 50;\n\n    // Private Inputs: User is ~25m away from the center\n    let user_lat: i64 = 48_858_550;\n    let user_lon: i64 = 2_294_650;\n\n    main(\n        user_lat,\n        user_lon,\n        eiffel_tower_lat,\n        eiffel_tower_lon,\n        radius,\n    );\n}\n\n#[test(should_fail_with = \"User is outside the specified radius\")]\nfn test_statue_of_liberty_fail() {\n    // Public Inputs: Prove you are within 100m of the Statue of Liberty\n    let liberty_lat: i64 = 40_689_247; // 40.689247\n    let liberty_lon: i64 = -74_044_502; // -74.044502\n    let radius: i64 = 100;\n\n    // Private Inputs: User is far away in another part of the city\n    let user_lat: i64 = 40_758_000; // Times Square\n    let user_lon: i64 = -73_985_500;\n\n    main(user_lat, user_lon, liberty_lat, liberty_lon, radius);\n}\n","path":"/Users/surfer/Desktop/lol/geofence_prover/src/main.nr"}},"names":["main"],"brillig_names":["print_unconstrained","directive_integer_quotient","directive_invert"]}